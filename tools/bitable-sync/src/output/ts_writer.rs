use anyhow::{Context, Result};
use std::fmt::Write as FmtWrite;
use std::path::Path;

use crate::models::mock_data::MockData;

/// Generate mockData.ts content from MockData
pub fn generate_mock_data_ts(data: &MockData) -> Result<String> {
    let mut out = String::with_capacity(4096);

    // Header
    writeln!(out, "// Mock Data for Family Business")?;
    writeln!(out, "// Auto-generated by bitable-sync - DO NOT EDIT MANUALLY")?;
    writeln!(out)?;

    // Interfaces
    writeln!(out, "export interface StoreInfo {{")?;
    writeln!(out, "    name: string;")?;
    writeln!(out, "    phone: string;")?;
    writeln!(out, "    qrCodeUrl: string;")?;
    writeln!(out, "}}")?;
    writeln!(out)?;

    writeln!(out, "export interface MediaItem {{")?;
    writeln!(out, "    type: 'video' | 'image';")?;
    writeln!(out, "    url: string;")?;
    writeln!(out, "    title?: string;")?;
    writeln!(out, "    duration?: number; // for images, duration in ms")?;
    writeln!(out, "}}")?;
    writeln!(out)?;

    writeln!(out, "export interface Product {{")?;
    writeln!(out, "    id: string;")?;
    writeln!(out, "    name: string;")?;
    writeln!(out, "    description: string;")?;
    writeln!(out, "    price: number;")?;
    writeln!(out, "    image: string;")?;
    writeln!(out, "    categoryId: string;")?;
    writeln!(out, "}}")?;
    writeln!(out)?;

    writeln!(out, "export interface Category {{")?;
    writeln!(out, "    id: string;")?;
    writeln!(out, "    name: string;")?;
    writeln!(out, "    icon?: string;")?;
    writeln!(out, "}}")?;
    writeln!(out)?;

    // BASE_URL
    writeln!(
        out,
        "// Get base URL for assets (works with GitHub Pages subpath)"
    )?;
    writeln!(out, "const BASE_URL = import.meta.env.BASE_URL;")?;
    writeln!(out)?;

    // Store Info
    writeln!(out, "// Store Information")?;
    writeln!(out, "export const storeInfo: StoreInfo = {{")?;
    writeln!(out, "    name: {},", ts_string(&data.store_info.name))?;
    writeln!(out, "    phone: {},", ts_string(&data.store_info.phone))?;
    writeln!(
        out,
        "    qrCodeUrl: {}",
        ts_url(&data.store_info.qr_code_url)
    )?;
    writeln!(out, "}};")?;
    writeln!(out)?;

    // Media Playlist
    writeln!(
        out,
        "// Media playlist - videos and images for the ad display"
    )?;
    writeln!(out, "export const mediaPlaylist: MediaItem[] = [")?;
    for item in &data.media_playlist {
        writeln!(out, "    {{")?;
        writeln!(out, "        type: {},", ts_string(&item.media_type))?;
        writeln!(out, "        url: {},", ts_url(&item.url))?;
        if let Some(ref title) = item.title {
            writeln!(out, "        title: {},", ts_string(title))?;
        }
        if let Some(duration) = item.duration {
            writeln!(out, "        duration: {}", duration)?;
        } else {
            writeln!(out, "        duration: 5000")?;
        }
        writeln!(out, "    }},")?;
    }
    writeln!(out, "];")?;
    writeln!(out)?;

    // Categories
    writeln!(out, "// Categories - 黄酒分类")?;
    writeln!(out, "export const categories: Category[] = [")?;
    for cat in &data.categories {
        let icon_part = cat
            .icon
            .as_deref()
            .map(|i| format!(", icon: {}", ts_string(i)))
            .unwrap_or_default();
        writeln!(
            out,
            "    {{ id: {}, name: {}{} }},",
            ts_string(&cat.id),
            ts_string(&cat.name),
            icon_part
        )?;
    }
    writeln!(out, "];")?;
    writeln!(out)?;

    // Products
    writeln!(out, "// Products - 黄酒商品")?;
    writeln!(out, "export const products: Product[] = [")?;
    for product in &data.products {
        writeln!(out, "    {{")?;
        writeln!(out, "        id: {},", ts_string(&product.id))?;
        writeln!(
            out,
            "        categoryId: {},",
            ts_string(&product.category_id)
        )?;
        writeln!(out, "        name: {},", ts_string(&product.name))?;
        writeln!(
            out,
            "        description: {},",
            ts_string(&product.description)
        )?;
        writeln!(out, "        price: {},", format_price(product.price))?;
        writeln!(
            out,
            "        image: {}",
            ts_url(&product.image)
        )?;
    writeln!(out, "    }},")?;
    }
    writeln!(out, "];")?;
    writeln!(out)?;

    // Helper functions
    writeln!(out, "// Helper function to get products by category")?;
    writeln!(
        out,
        "export function getProductsByCategory(categoryId: string): Product[] {{"
    )?;
    writeln!(
        out,
        "    return products.filter(p => p.categoryId === categoryId);"
    )?;
    writeln!(out, "}}")?;
    writeln!(out)?;

    writeln!(out, "// Helper function to get product by id")?;
    writeln!(
        out,
        "export function getProductById(productId: string): Product | undefined {{"
    )?;
    writeln!(out, "    return products.find(p => p.id === productId);")?;
    writeln!(out, "}}")?;

    Ok(out)
}

/// Write mockData.ts to file
pub fn write_mock_data_ts(data: &MockData, output_path: &Path) -> Result<()> {
    let content = generate_mock_data_ts(data)?;

    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory: {}", parent.display()))?;
    }

    std::fs::write(output_path, &content)
        .with_context(|| format!("Failed to write {}", output_path.display()))?;

    tracing::info!(
        "Wrote mockData.ts ({} bytes, {} products, {} categories)",
        content.len(),
        data.products.len(),
        data.categories.len()
    );

    Ok(())
}

/// Generate a TypeScript URL expression.
/// Absolute URLs (http:// or https://) are emitted as plain string literals.
/// Relative paths are wrapped in `${BASE_URL}...` template literals.
/// Empty strings produce an empty string literal.
fn ts_url(url: &str) -> String {
    if url.is_empty() {
        "''".to_string()
    } else if url.starts_with("http://") || url.starts_with("https://") {
        format!("'{}'", url.replace('\'', "\\'"))
    } else {
        format!("`${{BASE_URL}}{}`", url)
    }
}

/// Escape a string for TypeScript string literal
fn ts_string(s: &str) -> String {
    let escaped = s
        .replace('\\', "\\\\")
        .replace('\'', "\\'")
        .replace('\n', "\\n");
    format!("'{}'", escaped)
}

/// Format price: show as integer if no decimals
fn format_price(price: f64) -> String {
    if price == price.floor() {
        format!("{}", price as i64)
    } else {
        format!("{}", price)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ts_url_relative_path() {
        assert_eq!(ts_url("images/qrcode.jpg"), "`${BASE_URL}images/qrcode.jpg`");
    }

    #[test]
    fn ts_url_relative_path_with_subdir() {
        assert_eq!(
            ts_url("videos/slug/index.m3u8"),
            "`${BASE_URL}videos/slug/index.m3u8`"
        );
    }

    #[test]
    fn ts_url_absolute_https() {
        assert_eq!(
            ts_url("https://example.com/image.png"),
            "'https://example.com/image.png'"
        );
    }

    #[test]
    fn ts_url_absolute_http() {
        assert_eq!(
            ts_url("http://example.com/image.png"),
            "'http://example.com/image.png'"
        );
    }

    #[test]
    fn ts_url_empty_string() {
        assert_eq!(ts_url(""), "''");
    }

    #[test]
    fn ts_url_absolute_with_single_quote() {
        assert_eq!(
            ts_url("https://example.com/it's-a-test"),
            "'https://example.com/it\\'s-a-test'"
        );
    }
}
